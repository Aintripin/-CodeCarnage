### Пришло время написать логику взаимодействия с сервером, работать с данными

JSON Placeholder:

```URL:
https://jsonplaceholder.typicode.com/
```

![[Pasted image 20241117194216.png]]

Это всё разрабатывалось поверх `JSON Server`

 У нас будет БД, в которую мы будем сохранять различные объекты, сущности. Причём, они могут быть сколь угодной сложности (со связями, сортировкой...)

`JSON placeholder`:

```URL:
https://github.com/typicode/json-server
```

Установка:

```BASH:
npm install json-server
```

Далее по [документации](https://github.com/typicode/json-server) мы создаём БД — это файлик, в котором наши данные и будут храниться:

![[Pasted image 20241117194615.png]]

Создадим отдельную папку в корне проекта и назовём её `./json-server`, внутри которой создаём файл с базой данных — `db.json`:

![[Pasted image 20241117194732.png]]

Касательно составляющей этого файла — скопируем из документации, а чуть позже адаптируем под себя:

![[Pasted image 20241117194821.png]]

Опять-таки, далее по [документации](https://github.com/typicode/json-server), сервер запускается через:

```BASH:
json-server --watch db.json
```

(это у него в видосе, у меня вот так написано в доках):

```BASH:
npx json-server db.json
```

В нашем случае, сам файл в папке, поэтому, соответственно поправим пути:

```BASH:
json-server --watch ./json-server/db.json
```

---
---
#### Лайфхак, чтобы видеть всё то, что и у него в видосе:

![[Pasted image 20241118112327.png]]



---
---


Видим, что сервак поднялся:

![[Pasted image 20241117195122.png]]

Можем также указать кастомный порт, на котором сервер будет крутиться:

```JSON:
json-server --watch ./json-server/db.json --port 8000
```

Этот сервер можно достаточно гибко настроить. По умолчанию, там никакой регистрации/авторизации нет

Мы можем создать вот такой файл:

![[Pasted image 20241118104957.png]]

Импортировать туда json-сервер и проч...

Нюанс в том, что новая документация, как оно часто бывает, более запутанная и обрезанная

На ветке `dependabot/...` получилось найти:

```JSON:
const jsonServer = require('json-server')
const server = jsonServer.create()
const router = jsonServer.router('db.json')
const middlewares = jsonServer.defaults()

// Set default middlewares (logger, static, cors and no-cache)
server.use(middlewares)

// Add custom routes before JSON Server router
server.get('/echo', (req, res) => {
  res.jsonp(req.query)
})

// To handle POST, PUT and PATCH you need to use a body-parser
// You can use the one used by JSON Server
server.use(jsonServer.bodyParser)
server.use((req, res, next) => {
  if (req.method === 'POST') {
    req.body.createdAt = Date.now()
  }
  // Continue to JSON Server router
  next()
})

// Use default router
server.use(router)
server.listen(3000, () => {
  console.log('JSON Server is running')
})
```

#### В общем, сейчас мы  сделаем имитацию авторизации по токену

С фронта будем отправлять просто за'hardcode'женную строчку, а сервер будет её проверять (своего рода, токен)

![[Pasted image 20241118105239.png]]

Если пользователь на фронте раз'логинится, то эту строку будем удалять

>`index.js`:

![[Pasted image 20241118105435.png]]
![[Pasted image 20241118105501.png]]
![[Pasted image 20241118105532.png]]
![[Pasted image 20241118105546.png]]


Т.е. сначала у нас идут все необходимые импорты:

![[Pasted image 20241118105635.png]]

Потом само создание json-сервера:

![[Pasted image 20241118105706.png]]
Вот это:

![[Pasted image 20241118105729.png]]

-- это middleware, которое просто добавляяет задержку между запросом и ответом, чтобы на фронте, из-за того, что мы всё локально разрабатываем, была хоть какая-то пауза. Т.е. имитация, чтобы запрос выполнялся не `0.1` секунду, а хотя бы 800-1000ms

Потом идёт другая middleware:

![[Pasted image 20241118105938.png]]

-- оно проверяет заголовки, которые мы присылаем в http-запросе:

![[Pasted image 20241118110035.png]]

И, если есть заголовок `authorization`, в котором находится наш токен, то запрос валидный -- значит пользователь авторизован

В обратном случае мы возвращаем `403` status code. Т.е. сообщаем нашему фронту о том, что пользователь не авторизован

Дальше уже идёт endpoint, пост-запрос, в котором мы проверяем, что пользователь ввёл правильный `username` и `пароль`:

![[Pasted image 20241118110500.png]]

И потом на `8000` порту запускаем сам сервер:

![[Pasted image 20241118110525.png]]


> `package.json`:

![[Pasted image 20241118110622.png]]


Терь ёбнем:

```BASH:
npm run start:dev:server
```

![[Pasted image 20241118110720.png]]

`json-server` мы установили глобально, а запустить мы пытаемся его через локальный пакет (что бы это ни значило)

Установим его, как dev-зависиомость:

```BASH:
npm i -D json-server
```

Как `-D`, потому что у нас этот сервак исключительно для разработки, это не production сервак


Ещё раз ёбнем:

```BASH:
npm run start:dev:server
```

Он запускается на `8000` порту:

![[Pasted image 20241118110947.png]]

Терь вот так:

![[Pasted image 20241118111012.png]]

Вместо данных - `auth error`

Теперь мы данные можем запрашивать только в том случае, если в заголовке `authorization` мы указываем какой-нить токен 


#### Как будет проходить сама авторизация

У нас в `db.json` есть вот такой массив `users`:

![[Pasted image 20241118111149.png]]

У каждого объекта есть `username` и `password`



Мы должны отправить `post`-запрос 

![[Pasted image 20241118111410.png]]

![[Pasted image 20241118114147.png]]

Нажимаем `Send`, т.е. отправляем запрос

Получаем `200` status code

И тут нам возвращается `id`'шник пользователя:

![[Pasted image 20241118111512.png]]

Этот `id`'шник мы будем использовать, как ключ 

Если мы указываем неправильный `username` или пароль, то нам возвращается `400` status code и `not found` сообщение

![[Pasted image 20241118111622.png]]


Попробуем запросить терь какие-то данные. Например, тот же массив постов:

![[Pasted image 20241118111711.png]]

После отправки запроса получаем `auth error`

##### НО, если мы добавим в заголовке запроса `authorization` и передадим туда абсолютно любую строку (потому что значение её не проверяется, а проверяется только факт наличия):

![[Pasted image 20241118111823.png]]

То получаем соответствующий массив


Это и есть иммитация авторизации, чтобы часть данных мог запрашивать только авторизованный пользователь 